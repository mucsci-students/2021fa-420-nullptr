nullptr UML++ Design Pattern Instances

- 1. Iterator (UMLData/UMLClass/CLI): 
CLI: Used in multiple methods, including doesClassExist,
doesFieldExist, findClass, and getClass. Note--despite being labeled as such,
variables marked as methodIter do not currently use this design pattern. These
all use standard C++ iterators.

UMLClass: Used for the checkParameter algorithm to see if a 
supplied attribute would break rules for duplicates and overloads. When a 
method is given, an iterator is used to loop through each parameter that exists
in the method being checked. 

CLI: Primarily in displaying classes, methods etc., iterators
are used to loop through the data model in order to grab each element from the 
vectors in order to display them to the user. Like in UMLData, iter is used 
for some variables but is not a part of the design pattern unless explicitly
using C++'s iterators (hold-over from JSMACH).

- 2. Observer (server.hpp): server.hpp acts as an observer that notifies 
UMLData  when its publisher (the GUI) has a specific event occur.

- 3. Template Method (UMLAttribute): UMLAttribute defines UMLMethod and UMLField,
allowing for standardized UMLAttribute operations but also allowing for 
identifier overloads and for a parameter list to exist in UMLMethod.

- 4. Template Method (CLI imported library, UMLCLI & CLITest): The CliLocalTerminalSession
is another instance of a template method, in this case expanding upon a general
CliSesssion. CLITest, which is used for implementing a separate file session for use in 
GMock, instead implements a CliFileSession, which similarly expands upon CliSession. 

- 5. Strategy (UMLAttribute, UMLMethod, UMLField, UMLData): Various 
operations in UMLData involve UMLAttributes, but can be interchangably 
done upon UMLMethods and UMLFields. For example, adding an attribute is 
simply addClassAttribute, but whatever's being held in the attr_ptr sent in 
can be a field, method, or standard attribute. 

- 6. Strategy (CLI imported library, UMLCLI): The CliLocalSession that is used for
UMLCLI specifically deploys a LoopScheduler. However, that same constructor is 
capable of implementing different types of schedulers from the library (such
as a boostascioscheduler), which, while being a different object, is pretty much 
interchangable due to it being a part of the 'family' of scheduler algorithms.
Thus, the imported library implements a form of strategy.

- 7. Adapter (UMLDataHistory): Use of std::stack, which is a container
adapter provided by the std library, for the sake of handling history.

- 8. Adapter (UMLFile): json and raw data generated by C code are not typically 
compatible. UMLFile handles this by converting information from a data model 
(in our case, UMLData) into the string of characters necessary to save a json 
file. It is also capable of doing the reverse, converting json into data model 
code for use in the UML class diagram editor.

- 9. Singleton (CLI imported library, UMLCLI): The LoopScheduler used for 
standard usage in UMLCLI uses std::mutex to ensure that there is a single 
point of access and that is thread-safe. 

- 10. Prototype (SVG imported library, index.html): Several parts of the SVG 
library that is used for graphics (such as Point, Matrix, SVGArray, etc.) all
follow the Prototype pattern of using clone() and making the constructor 
accessible through these clone methods specifically.

- 11. Composite (UMLData): UMLData is a composite of various UMLClasses and
UMLRelationships that are stored. The list of UMLClasses "classes" and 
the vector of UMLRelationships "relationships" could be considered collections 
of children for the mass data structure. Client code then works with all data 
through the composite UMLData data model structure. 

- 12. Facade (CLI imported library, UMLCLI): The Cli object acts as a facade,
handling the input stream, tab completion, and other features that make for
a complex CLI system. Using the facade doesn't require you to know how the 
tab completion implementation works--you can work with the small subsystem
of menu implementation to make the tab completion just work.